#!/usr/bin/env python

import sys

# HACK
sys.path.extend(['/vagrant', '/vagrant/env/lib/python2.7/site-packages'])

import argparse
import json
import os
import random
import re
import signal
import socket
from subprocess import call
import tempfile
import thread
import time

from tot import fs
from tot.config import get_user
from tot.config import get_user_mount_dir
from tot.config import setup_config


class Tracer(object):
    def __init__(self, host=None):
        self.retcode = None
        self.host = host or socket.gethostname()
        self.user = get_user()

    def trace(self, cmd):
        return iter([])


class STraceTracer(Tracer):

    def trace(self, cmd):
        self._make_fifo()

        thread.start_new_thread(self._run_trace, (cmd,))

        with open(self._fifo) as stream:
            for row in self._parse_strace(stream):
                yield row

        self._cleanup_fifo()

    def _make_fifo(self):
        self._tmp_path = tempfile.mkdtemp(prefix='tot_')
        self._fifo = os.path.join(self._tmp_path, 'fifo')
        os.mkfifo(self._fifo)

    def _cleanup_fifo(self):
        os.unlink(self._fifo)
        os.rmdir(self._tmp_path)

        self._fifo = None
        self._tmp_path = None

    def _run_trace(self, cmd):
        self.retcode = call([
            'strace', '-ttt', '-f',
            '-e', 'trace=open,close,execve,clone',
            '-o', self._fifo] + cmd)

    def _parse_args(self, expr):

        def parse_arg(arg):
            try:
                return int(arg)
            except ValueError:
                pass

            try:
                return float(arg)
            except ValueError:
                pass

            return arg

        def parse_string(i):
            assert expr[i] == '"'
            value = []

            i += 1
            while expr[i] != '"':
                if expr[i] == '\\':
                    # Skip next char.
                    i += 1
                    continue
                else:
                    value.append(expr[i])
                    i += 1

            return i + 1, ''.join(value)

        def parse_simple_value(i):
            value = []
            while i < len(expr):
                c = expr[i]
                if c in '),] ':
                    # End of value.
                    break
                else:
                    value.append(c)
                    i += 1

            return i, ''.join(value)

        def parse_list(i):
            args = []
            arg = []
            within_arg = False
            is_string = True

            while i < len(expr):
                c = expr[i]

                # Consume whitespace.
                if c in ', ':
                    i += 1

                elif c == '"':
                    # Start of string.
                    i, string = parse_string(i)
                    args.append(string)

                elif c == '[':
                    # Start of new list
                    i, args2 = parse_list(i + 1)
                    args.append(args2)

                elif c in '])':
                    # End of list.
                    i += 1
                    break

                elif c == '/':
                    # Start of comment.
                    i = expr.find('/', i + 1) + 1

                else:
                    # Simple value.
                    i, value = parse_simple_value(i)
                    args.append(parse_arg(value))

            return i, args

        i = 0
        i, args = parse_list(i)

        return args

    def _parse_strace(self, stream):
        for line in stream:
            pid, timestamp, rest = line.split(None, 2)
            try:
                func, rest = rest.split('(', 1)
            except ValueError:
                break

            pid = int(pid)
            args = self._parse_args(rest)

            yield {
                'type': 'trace',
                'host': self.host,
                'user': self.user,
                'pid': pid,
                'timestamp': timestamp,
                'func': func,
                'args': args,
            }


class Logger(object):

    def __init__(self, stream):
        self.stream = stream

    def log(self, row):
        self.stream.write(json.dumps(row, sort_keys=True))
        self.stream.write('\n')
        self.stream.flush()


# Command parser.
parser = argparse.ArgumentParser()

parser.add_argument('--log', default='tot.log',
                    help='log file')
parser.add_argument('--log-fs', default='tot-fs.log',
                    help='log fs file')
parser.add_argument('--chroot', type=int)


# Parse command line arguments.
args, rest = parser.parse_known_args()

# Setup user config.
setup_config()
mount_dir = get_user_mount_dir()

if not args.chroot:
    # Need to setup chroot fs.

    # Setup fs shim.
    child_pid = os.fork()
    if child_pid == 0:
        logger_fs = Logger(open(args.log_fs, 'a'))
        tot_fs = fs.TotFS(logger_fs.log)
        tot_fs.mount(mount_dir)
        # Runs forever.

    assert child_pid != 0

    # Wait for mount to setup.
    while not os.listdir(mount_dir):
        time.sleep(.01)

    # Rexecute within chroot.
    tot = os.path.abspath(__file__)
    retcode = call(
        ['tot-chroot', tot, '--chroot', str(child_pid)] + sys.argv[1:])

    # Kill mount process.
    os.kill(child_pid, signal.SIGKILL)
    fs.unmount(mount_dir)

    sys.exit(retcode)

# chroot fs is already in place, start tracing.
# Setup logger.
logger = Logger(open(args.log, 'a'))

# Run tracer and log events.
cmd = rest
tracer = STraceTracer()
for row in tracer.trace(cmd):
    logger.log(row)

sys.exit(tracer.retcode)
